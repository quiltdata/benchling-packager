Description: TODO
Outputs:
  TemplateBuildMetadata:
    Description: Metadata generated by the Quilt build system.
    Value: '{"git_revision": "75114844f24888039d63bd8aad3e441e90818739", "git_repository": "/Users/quilt/Documents/GitHub/benchling-packager", "make_time": "2023-06-06 18:23:03.220177+00:00"}'
Parameters:
  BenchlingEventBusName:
    Type: String
    Description: Name of event bus where Benchling events are emitted, e.g aws.partner/benchling.com/tenant/app-name
  BenchlingTenant:
    Type: String
    AllowedPattern: ^[^/]+$
    Description: Benchling tenant name, i.e. $BenchlingTenant in https://$BenchlingTenant.benchling.com
  BenchlingClientId:
    Type: String
    Description: Client ID of Benchling app
  QuiltDomain:
    Type: String
    AllowedPattern: ^[^/]+$
    Description: Domain you use to access Quilt, e.g. quilt.you.company.com
  DestinationBucket:
    Type: String
    AllowedPattern: ^[\.\-a-z0-9]{3,63}$
    Description: The name of S3 bucket where packages will be created
  PackageNamePrefix:
    Type: String
    Default: benchling/
    AllowedPattern: .+/.*$
    Description: Prefix for package names i.e. package names will be $PackageNamePrefix$ExperimentDisplayID, must contain, but not start with '/'
Resources:
  Layer:
    Properties:
      Content:
        S3Bucket: !Sub 'quilt-lambda-${AWS::Region}'
        S3Key: benchling-packager/benchling-packager-layer.zip
    Type: AWS::Lambda::LayerVersion
  BenchlingClientSecret:
    Type: AWS::SecretsManager::Secret
  LambdaRole:
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: ''
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: secretsmanager:GetSecretValue
                Resource: !Ref 'BenchlingClientSecret'
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectTagging
                  - s3:GetObjectVersion
                  - s3:GetObjectVersionTagging
                  - s3:ListBucket
                  - s3:ListBucketVersions
                  - s3:PutObject
                  - s3:PutObjectTagging
                Resource:
                  - !Sub 'arn:aws:s3:::${DestinationBucket}'
                  - !Sub 'arn:aws:s3:::${DestinationBucket}/*'
    Type: AWS::IAM::Role
  Lambda:
    Properties:
      Role: !GetAtt 'LambdaRole.Arn'
      Runtime: python3.9
      Timeout: 900
      Layers:
        - !Ref 'Layer'
      Environment:
        Variables:
          LOG_LEVEL: DEBUG
          POWERTOOLS_LOGGER_LOG_EVENT: '1'
          BENCHLING_TENANT: !Ref 'BenchlingTenant'
          BENCHLING_CLIENT_ID: !Ref 'BenchlingClientId'
          BENCHLING_CLIENT_SECRET_ARN: !Ref 'BenchlingClientSecret'
          DST_BUCKET: !Ref 'DestinationBucket'
          PKG_PREFIX: !Ref 'PackageNamePrefix'
          QUILT_CATALOG_DOMAIN: !Ref 'QuiltDomain'
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          import io
          import os
          import pathlib
          import tempfile
          import urllib
          import zipfile

          import jinja2
          import quilt3
          from aws_lambda_powertools import Logger
          from aws_lambda_powertools.utilities import parameters
          from benchling_sdk import models as benchling_models
          from benchling_sdk.auth.client_credentials_oauth2 import ClientCredentialsOAuth2
          from benchling_sdk.benchling import Benchling
          from benchling_sdk.helpers import serialization_helpers

          logger = Logger()


          BENCHLING_TENANT = os.environ["BENCHLING_TENANT"]
          BENCHLING_TENANT_URL = f"https://{BENCHLING_TENANT}.benchling.com"
          BENCHLING_CLIENT_ID = os.environ["BENCHLING_CLIENT_ID"]
          BENCHLING_CLIENT_SECRET_ARN = os.environ["BENCHLING_CLIENT_SECRET_ARN"]
          DST_BUCKET = os.environ["DST_BUCKET"]
          PKG_PREFIX = os.environ["PKG_PREFIX"]
          QUILT_CATALOG_DOMAIN = os.environ["QUILT_CATALOG_DOMAIN"]


          benchling = Benchling(
              url=BENCHLING_TENANT_URL,
              auth_method=ClientCredentialsOAuth2(
                  client_id=BENCHLING_CLIENT_ID,
                  client_secret=parameters.get_secret(BENCHLING_CLIENT_SECRET_ARN),
                  token_url=BENCHLING_TENANT_URL + "/api/v2/token",
              ),
          )


          template = jinja2.Template(
              """# [{{ entry.name }}]({{ entry.webURL }})

          * id: {{ entry.id }}
          * displayId: {{ entry.displayId }}
          * folderId: {{ entry.folderId }}
          * createdAt: {{ entry.createdAt }}
          * modifiedAt: {{ entry.modifiedAt }}

          ## Authors
          {% for author in entry.authors %}
          * {{ author.name }}
            * id: {{ author.id }}
            * handle: {{ author.handle }}
          {%- endfor %}

          ## Schema

          * id: {{ entry.schema.id }}
          * name: {{ entry.schema.name }}

          ## Fields
          {% for name, value in entry.fields.items() %}
          * {{ name }}: {{ value.displayValue }}
          {%- endfor %}

          ## Custom fields
          {% for name, value in entry.customFields.items() %}
          * {{ name }}: {{ value.value }}
          {%- endfor %}
          """
          )


          QUILT_SUMMARIZE = """[
              "notes.pdf"
          ]
          """


          @logger.inject_lambda_context
          def lambda_handler(event, context):
              entry = event["detail"]["entry"]
              task = benchling.tasks.wait_for_task(
                  benchling.exports.export(
                      benchling_models.ExportItemRequest(id=entry["id"])
                  ).task_id
              )
              if task.status != benchling_models.AsyncTaskStatus.SUCCEEDED:
                  raise Exception(f"Notes export failed: {task!r}")

              with urllib.request.urlopen(task.response["downloadURL"]) as src:
                  buf = io.BytesIO(src.read())

              with tempfile.TemporaryDirectory() as tmpdir:
                  tmpdir_path = pathlib.Path(tmpdir)

                  (tmpdir_path / "README.md").write_text(template.render({"entry": entry}))

                  with zipfile.ZipFile(buf) as zip_file:
                      with zip_file.open(zip_file.namelist()[0]) as src:
                          with (tmpdir_path / "notes.pdf").open("wb") as dst:
                              while data := src.read(4096):
                                  dst.write(data)

                  (tmpdir_path / "quilt_summarize.json").write_text(QUILT_SUMMARIZE)

                  pkg_name = PKG_PREFIX + entry["displayId"]
                  quilt3.Package().set_dir(
                      ".",
                      tmpdir_path,
                      # This shouldn't hit 1 MB limit on metadata, because max size of EventBridge is 256 KiB.
                      meta=entry,
                  ).push(
                      pkg_name,
                      registry=f"s3://{DST_BUCKET}",
                      force=True,  # FIXME
                  )

                  fields_values = {}
                  if "Quilt+ URI" in entry["fields"]:
                      fields_values["Quilt+ URI"] = f"quilt+s3://{DST_BUCKET}#package={pkg_name}"
                  if "Quilt Catalog URL" in entry["fields"]:
                      fields_values[
                          "Quilt Catalog URL"
                      ] = f"https://{QUILT_CATALOG_DOMAIN}/b/{DST_BUCKET}/packages/{pkg_name}"
                  # TODO: check that this URL is correct
                  if "Quilt DropZone URL" in entry["fields"]:
                      fields_values[
                          "Quilt DropZone URL"
                      ] = f"https://{QUILT_CATALOG_DOMAIN}/b/{DST_BUCKET}/packages/{pkg_name}/?createPackage=true&dropZoneOnly=true&msg=Commit+Message"

                  if fields_values:
                      benchling.entries.update_entry(
                          event["detail"]["entry"]["id"],
                          benchling_models.EntryUpdate(
                              fields=serialization_helpers.fields(
                                  {
                                      name: {"value": value}
                                      for name, value in fields_values.items()
                                  }
                              )
                          ),
                      )
      ReservedConcurrentExecutions: 1
      MemorySize: 512
    Type: AWS::Lambda::Function
  EventBusRule:
    Properties:
      EventBusName: !Ref 'BenchlingEventBusName'
      EventPattern:
        source:
          - !Ref 'BenchlingEventBusName'
        detail-type:
          - v2.entry.created
          - v2.entry.updated.fields
      Targets:
        - Id: Lambda
          Arn: !GetAtt 'Lambda.Arn'
    Type: AWS::Events::Rule
  LambdaPermission:
    Properties:
      FunctionName: !GetAtt 'Lambda.Arn'
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt 'EventBusRule.Arn'
    Type: AWS::Lambda::Permission
