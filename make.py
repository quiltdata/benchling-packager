import datetime
import json
import os
import pathlib
import subprocess
import sys

import troposphere
from troposphere import awslambda, events, iam, secretsmanager

DEBUG = True
LAMBDAS_DIR = pathlib.Path("lambdas")
LAMBDA_MAX_DURATION_SEC = 60 * 15
LAMBDA_RUNTIME = "python3.9"
LAMBDA_ASSUME_ROLE_POLICY = {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "",
            "Effect": "Allow",
            "Principal": {"Service": "lambda.amazonaws.com"},
            "Action": "sts:AssumeRole",
        },
    ],
}
LAMBDA_POWERTOOLS_LAYER_ARN = troposphere.Sub(
    "arn:aws:lambda:${AWS::Region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:15"
)


def get_lambda_layers(*extra_layers):
    return [
        # LAMBDA_POWERTOOLS_LAYER_ARN,
        *extra_layers,
    ]


def make_lambda_environment(**kwargs):
    return awslambda.Environment(
        Variables={
            "LOG_LEVEL": "DEBUG" if DEBUG else "INFO",
            "POWERTOOLS_LOGGER_LOG_EVENT": "1" if DEBUG else "0",
            **kwargs,
        }
    )


def get_metadata():
    """build-time metadata for inclusion in template"""
    return {
        "git_revision": subprocess.run(
            ("git", "rev-parse", "HEAD"), capture_output=True, text=True
        ).stdout.rstrip(),
        "git_repository": subprocess.run(
            ("git", "rev-parse", "--show-toplevel"), capture_output=True, text=True
        ).stdout.rstrip(),
        "make_time": str(datetime.datetime.now(datetime.timezone.utc)),
    }


def make_layer(cft: troposphere.Template):
    return awslambda.LayerVersion(
        "Layer",
        template=cft,
        Content=awslambda.Content(
            S3Bucket=troposphere.Sub("quilt-lambda-${AWS::Region}"),
            S3Key="benchling-packager/benchling-packager-layer.zip",
        ),
    )


def make_template(*, metadata: dict) -> troposphere.Template:
    description = "TODO"  # TODO
    cft = troposphere.Template(Description=description)
    troposphere.Output(
        "TemplateBuildMetadata",
        template=cft,
        Description="Metadata generated by the Quilt build system.",
        Value=json.dumps(metadata),
    )

    bus_name = troposphere.Parameter(
        "BenchlingEventBusName",
        template=cft,
        Type="String",
    )
    # TODO: looks like we can derive tenant from bus name,
    #       is it guaranteed?
    benchling_tenant = troposphere.Parameter(
        "BenchlingTenant",
        template=cft,
        Type="String",
    )
    benchling_client_id = troposphere.Parameter(
        "BenchlingClientId",
        template=cft,
        Type="String",
    )
    # TODO: add AllowedPattern
    # TODO: currently it assumes https is provided by user
    quilt_url = troposphere.Parameter(
        "QuiltUrl",
        template=cft,
        Type="String",
    )
    dst_bucket = troposphere.Parameter(
        "DestinationBucket",
        template=cft,
        Type="String",
    )
    # TODO: add AllowedPattern
    pkg_prefix = troposphere.Parameter(
        "PackagePrefix",
        template=cft,
        Type="String",
        Default="benchling/",
    )

    make_layer(cft)
    benchling_client_secret = secretsmanager.Secret(
        "BenchlingClientSecret",
        template=cft,
    )
    role = iam.Role(
        "LambdaRole",
        template=cft,
        AssumeRolePolicyDocument=LAMBDA_ASSUME_ROLE_POLICY,
        ManagedPolicyArns=[
            "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
        ],
        Policies=[
            iam.Policy(
                PolicyName="root",
                PolicyDocument={
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Effect": "Allow",
                            "Action": "secretsmanager:GetSecretValue",
                            "Resource": benchling_client_secret.ref(),
                        },
                        {
                            "Effect": "Allow",
                            "Action": [
                                "s3:GetObject",
                                "s3:GetObjectTagging",
                                "s3:GetObjectVersion",
                                "s3:GetObjectVersionTagging",
                                "s3:ListBucket",
                                "s3:ListBucketVersions",
                                "s3:PutObject",
                                "s3:PutObjectTagging",
                            ],
                            "Resource": [
                                troposphere.Sub("arn:aws:s3:::${DestinationBucket}"),
                                troposphere.Sub("arn:aws:s3:::${DestinationBucket}/*"),
                            ],
                        },
                    ],
                },
            ),
        ],
    )
    function = awslambda.Function(
        "Lambda",
        template=cft,
        Role=role.get_att("Arn"),
        Runtime=LAMBDA_RUNTIME,
        Timeout=LAMBDA_MAX_DURATION_SEC,
        # VpcConfig=make_lambda_vpc_config([troposphere.Ref("DBAccessorSecurityGroup")]),
        Layers=get_lambda_layers(troposphere.Ref("Layer")),
        Environment=make_lambda_environment(
            BENCHLING_TENANT=benchling_tenant.ref(),
            BENCHLING_CLIENT_ID=benchling_client_id.ref(),
            BENCHLING_CLIENT_SECRET_ARN=benchling_client_secret.ref(),
            DST_BUCKET=dst_bucket.ref(),
            PKG_PREFIX=pkg_prefix.ref(),
            QUILT_CATALOG_URL=quilt_url.ref(),
        ),
        Handler="index.lambda_handler",
        Code=awslambda.Code(ZipFile=(LAMBDAS_DIR / "lambda.py").read_text()),
        ReservedConcurrentExecutions=1,  # FIXME
        MemorySize=512,
    )
    rule = events.Rule(
        "EventBusRule",
        template=cft,
        EventBusName=bus_name.ref(),
        EventPattern={
            "source": [bus_name.ref()],
            "detail-type": ["v2.entry.created", "v2.entry.updated.fields"],
        },
        Targets=[
            events.Target(
                Id=function.title,
                Arn=function.get_att("Arn"),
            )
        ],
    )
    awslambda.Permission(
        "LambdaPermission",
        template=cft,
        FunctionName=function.get_att("Arn"),
        Action="lambda:InvokeFunction",
        Principal="events.amazonaws.com",
        SourceArn=rule.get_att("Arn"),
    )

    return cft


if __name__ == "__main__":
    cft = make_template(
        metadata=get_metadata(),
    )
    # sort_keys=False is a lucky way to get the Description with the
    # copyright on top; it could break (but not catastrophically)
    sys.stdout.write(cft.to_yaml(sort_keys=False))
